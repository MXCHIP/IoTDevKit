/************************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.3.9.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * Generated Date: Friday, August 9, 2019
 ***********************************************************************************************/

#include "settings_interface.h"

#define MAX_MASSAGE_SIZE 256

//
// Callback function declarations and DigitalTwin writable (from service side) properties for this interface
//

static void SettingsInterface_Property_FanSpeedCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext);

static void SettingsInterface_Property_VoltageCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext);

static void SettingsInterface_Property_CurrentCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext);

static void SettingsInterface_Property_IrSwitchCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext);

//
// Application state associated with this interface. In particular it contains 
// the DIGITALTWIN_INTERFACE_CLIENT_HANDLE used for responses in callbacks along with properties set
// and representations of the properrty update and command callbacks invoked on given interface
//
typedef struct SETTINGS_INTERFACE_STATE_TAG
{
    DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceClientHandle;

    double fanSpeed;

    double voltage;

    double current;

    bool irSwitch;

} SETTINGS_INTERFACE_STATE;

static SETTINGS_INTERFACE_STATE appState;

// SettingsInterface_PropertyCallback is invoked when a property is updated (or failed) going to server.
// ALL property callbacks will be routed to this function and just have the userContextCallback set to the propertyName.
// Product code will potentially have context stored in this userContextCallback.
static void SettingsInterface_PropertyCallback(DIGITALTWIN_CLIENT_RESULT digitalTwinReportedStatus, void* userContextCallback)
{
    if (digitalTwinReportedStatus == DIGITALTWIN_CLIENT_OK)
    {
        ReportProperty_Succeeded_Callback("Settings", (const char*)userContextCallback);
        LogInfo("SETTINGS_INTERFACE: Updating property=<%s> succeeded", (const char*)userContextCallback);
    }
    else
    {
        ReportProperty_Error_Callback("Settings", (const char*)userContextCallback);
        LogError("SETTINGS_INTERFACE: Updating property=<%s> failed, error=<%s>", (const char*)userContextCallback, MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinReportedStatus));
    }
}

// Processes a property update, which the server initiated, for 'fanSpeed' property.
static void SettingsInterface_Property_FanSpeedCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext)
{
    SETTINGS_INTERFACE_STATE* interfaceState = (SETTINGS_INTERFACE_STATE*)userInterfaceContext;

    LogInfo("SETTINGS_INTERFACE: fanSpeed property invoked...");
    LogInfo("SETTINGS_INTERFACE: fanSpeed data=<%.*s>", (int)dtClientPropertyUpdate->propertyDesiredLen, dtClientPropertyUpdate->propertyDesired);

    DIGITALTWIN_CLIENT_PROPERTY_RESPONSE propertyResponse;

    // Version of this structure for C SDK.
    propertyResponse.version = DIGITALTWIN_CLIENT_PROPERTY_RESPONSE_VERSION_1;
    propertyResponse.responseVersion = dtClientPropertyUpdate->desiredVersion;

    // Parse string value and set updated property
    JSON_Value * jsonValue = json_parse_string((const char*)dtClientPropertyUpdate->propertyDesired);

    double newValue = json_value_get_number(jsonValue);

    bool isTypeValid = (json_value_get_type(jsonValue) == JSONNumber);

    if (isTypeValid)
    {
        interfaceState->fanSpeed = (double)newValue;

        LogInfo("SETTINGS_INTERFACE: Updating fanSpeed property with new value <%s> ...", dtClientPropertyUpdate->propertyDesired);
        bool updateResult = Settings_Property_FanSpeedCallback(interfaceState->fanSpeed);
 
        if (updateResult)
        {
            propertyResponse.statusCode = 200;
            propertyResponse.statusDescription = "fanSpeed property is updated successfully";
        }
        else
        {
            LogError("SETTINGS_INTERFACE: failed to update writable property fanSpeed...");

            propertyResponse.statusCode = 500;
            propertyResponse.statusDescription = "failed to update writable property";
        }
    }
    else
    {
        LogError("SETTINGS_INTERFACE: Invalid desired value for fanSpeed, value should be Double");
        propertyResponse.statusCode = 500;
        propertyResponse.statusDescription = "Invalid desired value for fanSpeed, value should be Double";
    }
    json_value_free(jsonValue);

    // DigitalTwin_InterfaceClient_ReportPropertyAsync takes the DIGITALTWIN_CLIENT_PROPERTY_RESPONSE and returns information back to service.
    DIGITALTWIN_CLIENT_RESULT result = DigitalTwin_InterfaceClient_ReportPropertyAsync(appState.interfaceClientHandle, SettingsInterface_FanSpeedProperty, 
        (const char*)dtClientPropertyUpdate->propertyDesired, &propertyResponse,
        SettingsInterface_PropertyCallback, SettingsInterface_FanSpeedProperty);
    if (result != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SETTINGS_INTERFACE: DigitalTwin_InterfaceClient_ReportPropertyAsync for fanSpeed failed, error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
    }
    else
    {
        LogInfo("SETTINGS_INTERFACE: Successfully queued property update for fanSpeed");
    }
}

// Processes a property update, which the server initiated, for 'voltage' property.
static void SettingsInterface_Property_VoltageCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext)
{
    SETTINGS_INTERFACE_STATE* interfaceState = (SETTINGS_INTERFACE_STATE*)userInterfaceContext;

    LogInfo("SETTINGS_INTERFACE: voltage property invoked...");
    LogInfo("SETTINGS_INTERFACE: voltage data=<%.*s>", (int)dtClientPropertyUpdate->propertyDesiredLen, dtClientPropertyUpdate->propertyDesired);

    DIGITALTWIN_CLIENT_PROPERTY_RESPONSE propertyResponse;

    // Version of this structure for C SDK.
    propertyResponse.version = DIGITALTWIN_CLIENT_PROPERTY_RESPONSE_VERSION_1;
    propertyResponse.responseVersion = dtClientPropertyUpdate->desiredVersion;

    // Parse string value and set updated property
    JSON_Value * jsonValue = json_parse_string((const char*)dtClientPropertyUpdate->propertyDesired);

    double newValue = json_value_get_number(jsonValue);

    bool isTypeValid = (json_value_get_type(jsonValue) == JSONNumber);

    if (isTypeValid)
    {
        interfaceState->voltage = (double)newValue;

        LogInfo("SETTINGS_INTERFACE: Updating voltage property with new value <%s> ...", dtClientPropertyUpdate->propertyDesired);
        bool updateResult = Settings_Property_VoltageCallback(interfaceState->voltage);
 
        if (updateResult)
        {
            propertyResponse.statusCode = 200;
            propertyResponse.statusDescription = "voltage property is updated successfully";
        }
        else
        {
            LogError("SETTINGS_INTERFACE: failed to update writable property voltage...");

            propertyResponse.statusCode = 500;
            propertyResponse.statusDescription = "failed to update writable property";
        }
    }
    else
    {
        LogError("SETTINGS_INTERFACE: Invalid desired value for voltage, value should be Double");
        propertyResponse.statusCode = 500;
        propertyResponse.statusDescription = "Invalid desired value for voltage, value should be Double";
    }
    json_value_free(jsonValue);

    // DigitalTwin_InterfaceClient_ReportPropertyAsync takes the DIGITALTWIN_CLIENT_PROPERTY_RESPONSE and returns information back to service.
    DIGITALTWIN_CLIENT_RESULT result = DigitalTwin_InterfaceClient_ReportPropertyAsync(appState.interfaceClientHandle, SettingsInterface_VoltageProperty, 
        (const char*)dtClientPropertyUpdate->propertyDesired, &propertyResponse,
        SettingsInterface_PropertyCallback, SettingsInterface_VoltageProperty);
    if (result != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SETTINGS_INTERFACE: DigitalTwin_InterfaceClient_ReportPropertyAsync for voltage failed, error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
    }
    else
    {
        LogInfo("SETTINGS_INTERFACE: Successfully queued property update for voltage");
    }
}

// Processes a property update, which the server initiated, for 'current' property.
static void SettingsInterface_Property_CurrentCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext)
{
    SETTINGS_INTERFACE_STATE* interfaceState = (SETTINGS_INTERFACE_STATE*)userInterfaceContext;

    LogInfo("SETTINGS_INTERFACE: current property invoked...");
    LogInfo("SETTINGS_INTERFACE: current data=<%.*s>", (int)dtClientPropertyUpdate->propertyDesiredLen, dtClientPropertyUpdate->propertyDesired);

    DIGITALTWIN_CLIENT_PROPERTY_RESPONSE propertyResponse;

    // Version of this structure for C SDK.
    propertyResponse.version = DIGITALTWIN_CLIENT_PROPERTY_RESPONSE_VERSION_1;
    propertyResponse.responseVersion = dtClientPropertyUpdate->desiredVersion;

    // Parse string value and set updated property
    JSON_Value * jsonValue = json_parse_string((const char*)dtClientPropertyUpdate->propertyDesired);

    double newValue = json_value_get_number(jsonValue);

    bool isTypeValid = (json_value_get_type(jsonValue) == JSONNumber);

    if (isTypeValid)
    {
        interfaceState->current = (double)newValue;

        LogInfo("SETTINGS_INTERFACE: Updating current property with new value <%s> ...", dtClientPropertyUpdate->propertyDesired);
        bool updateResult = Settings_Property_CurrentCallback(interfaceState->current);
 
        if (updateResult)
        {
            propertyResponse.statusCode = 200;
            propertyResponse.statusDescription = "current property is updated successfully";
        }
        else
        {
            LogError("SETTINGS_INTERFACE: failed to update writable property current...");

            propertyResponse.statusCode = 500;
            propertyResponse.statusDescription = "failed to update writable property";
        }
    }
    else
    {
        LogError("SETTINGS_INTERFACE: Invalid desired value for current, value should be Double");
        propertyResponse.statusCode = 500;
        propertyResponse.statusDescription = "Invalid desired value for current, value should be Double";
    }
    json_value_free(jsonValue);

    // DigitalTwin_InterfaceClient_ReportPropertyAsync takes the DIGITALTWIN_CLIENT_PROPERTY_RESPONSE and returns information back to service.
    DIGITALTWIN_CLIENT_RESULT result = DigitalTwin_InterfaceClient_ReportPropertyAsync(appState.interfaceClientHandle, SettingsInterface_CurrentProperty, 
        (const char*)dtClientPropertyUpdate->propertyDesired, &propertyResponse,
        SettingsInterface_PropertyCallback, SettingsInterface_CurrentProperty);
    if (result != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SETTINGS_INTERFACE: DigitalTwin_InterfaceClient_ReportPropertyAsync for current failed, error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
    }
    else
    {
        LogInfo("SETTINGS_INTERFACE: Successfully queued property update for current");
    }
}

// Processes a property update, which the server initiated, for 'irSwitch' property.
static void SettingsInterface_Property_IrSwitchCallback(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext)
{
    SETTINGS_INTERFACE_STATE* interfaceState = (SETTINGS_INTERFACE_STATE*)userInterfaceContext;

    LogInfo("SETTINGS_INTERFACE: irSwitch property invoked...");
    LogInfo("SETTINGS_INTERFACE: irSwitch data=<%.*s>", (int)dtClientPropertyUpdate->propertyDesiredLen, dtClientPropertyUpdate->propertyDesired);

    DIGITALTWIN_CLIENT_PROPERTY_RESPONSE propertyResponse;

    // Version of this structure for C SDK.
    propertyResponse.version = DIGITALTWIN_CLIENT_PROPERTY_RESPONSE_VERSION_1;
    propertyResponse.responseVersion = dtClientPropertyUpdate->desiredVersion;

    // Parse string value and set updated property
    JSON_Value * jsonValue = json_parse_string((const char*)dtClientPropertyUpdate->propertyDesired);

    bool isTypeValid = (json_value_get_type(jsonValue) == JSONBoolean);
    bool newValue = json_value_get_boolean(jsonValue);

    if (isTypeValid)
    {
        interfaceState->irSwitch = (bool)newValue;

        LogInfo("SETTINGS_INTERFACE: Updating irSwitch property with new value <%s> ...", dtClientPropertyUpdate->propertyDesired);
        bool updateResult = Settings_Property_IrSwitchCallback(interfaceState->irSwitch);
 
        if (updateResult)
        {
            propertyResponse.statusCode = 200;
            propertyResponse.statusDescription = "irSwitch property is updated successfully";
        }
        else
        {
            LogError("SETTINGS_INTERFACE: failed to update writable property irSwitch...");

            propertyResponse.statusCode = 500;
            propertyResponse.statusDescription = "failed to update writable property";
        }
    }
    else
    {
        LogError("SETTINGS_INTERFACE: Invalid desired value for irSwitch, value should be Boolean");
        propertyResponse.statusCode = 500;
        propertyResponse.statusDescription = "Invalid desired value for irSwitch, value should be Boolean";
    }
    json_value_free(jsonValue);

    // DigitalTwin_InterfaceClient_ReportPropertyAsync takes the DIGITALTWIN_CLIENT_PROPERTY_RESPONSE and returns information back to service.
    DIGITALTWIN_CLIENT_RESULT result = DigitalTwin_InterfaceClient_ReportPropertyAsync(appState.interfaceClientHandle, SettingsInterface_IrSwitchProperty, 
        (const char*)dtClientPropertyUpdate->propertyDesired, &propertyResponse,
        SettingsInterface_PropertyCallback, SettingsInterface_IrSwitchProperty);
    if (result != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SETTINGS_INTERFACE: DigitalTwin_InterfaceClient_ReportPropertyAsync for irSwitch failed, error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
    }
    else
    {
        LogInfo("SETTINGS_INTERFACE: Successfully queued property update for irSwitch");
    }
}

// SettingsInterface_ProcessPropertyUpdate receives updated properties from the server.  This implementation
// acts as a simple dispatcher to the functions to perform the actual processing.
static void SettingsInterface_ProcessPropertyUpdate(const DIGITALTWIN_CLIENT_PROPERTY_UPDATE* dtClientPropertyUpdate, void* userInterfaceContext)
{
    if (strcmp(dtClientPropertyUpdate->propertyName, SettingsInterface_FanSpeedProperty) == 0)
    {
        SettingsInterface_Property_FanSpeedCallback(dtClientPropertyUpdate, userInterfaceContext);
        return;
    }

    if (strcmp(dtClientPropertyUpdate->propertyName, SettingsInterface_VoltageProperty) == 0)
    {
        SettingsInterface_Property_VoltageCallback(dtClientPropertyUpdate, userInterfaceContext);
        return;
    }

    if (strcmp(dtClientPropertyUpdate->propertyName, SettingsInterface_CurrentProperty) == 0)
    {
        SettingsInterface_Property_CurrentCallback(dtClientPropertyUpdate, userInterfaceContext);
        return;
    }

    if (strcmp(dtClientPropertyUpdate->propertyName, SettingsInterface_IrSwitchProperty) == 0)
    {
        SettingsInterface_Property_IrSwitchCallback(dtClientPropertyUpdate, userInterfaceContext);
        return;
    }

    // If the property is not implemented by this interface, presently we only record a log message but do not have a mechanism to report back to the service
    LogError("SETTINGS_INTERFACE: Property name <%s> is not associated with this interface", dtClientPropertyUpdate->propertyName);
}

// SettingsInterface_InterfaceRegisteredCallback is invoked when this interface
// is successfully or unsuccessfully registered with the service, and also when the interface is deleted.
static void SettingsInterface_InterfaceRegisteredCallback(DIGITALTWIN_CLIENT_RESULT dtInterfaceStatus, void* userInterfaceContext)
{
    LogInfo("SettingsInterface_InterfaceRegisteredCallback with status=<%s>, userContext=<%p>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, dtInterfaceStatus), userInterfaceContext);
    if (dtInterfaceStatus == DIGITALTWIN_CLIENT_OK)
    {
        // Once the interface is registered, send our reported properties to the service.  
        // It *IS* safe to invoke most DigitalTwin API calls from a callback thread like this, though it 
        // is NOT safe to create/destroy/register interfaces now.
        LogInfo("SETTINGS_INTERFACE: Interface successfully registered.");
    }
    else if (dtInterfaceStatus == DIGITALTWIN_CLIENT_ERROR_INTERFACE_UNREGISTERING)
    {
        // Once an interface is marked as unregistered, it cannot be used for any DigitalTwin SDK calls.
        LogInfo("SETTINGS_INTERFACE: Interface received unregistering callback.");
    }
    else
    {
        LogError("SETTINGS_INTERFACE: Interface received failed, status=<%s>.", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, dtInterfaceStatus));
    }
}

//
// Create DigitalTwin interface cllient handle
//
DIGITALTWIN_INTERFACE_CLIENT_HANDLE SettingsInterface_Create()
{
    DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceHandle;
    DIGITALTWIN_CLIENT_RESULT result;

    memset(&appState, 0, sizeof(SETTINGS_INTERFACE_STATE));

    if ((result = DigitalTwin_InterfaceClient_Create(SettingsInterfaceId,  SettingsInterfaceInstanceName, SettingsInterface_InterfaceRegisteredCallback, (void*)&appState, &interfaceHandle)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SETTINGS_INTERFACE: Unable to allocate interface client handle for interfaceId=<%s>, interfaceInstanceName=<%s>, error=<%s>", SettingsInterfaceId, SettingsInterfaceInstanceName, MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        interfaceHandle = NULL;
    }

    else if ((result = DigitalTwin_InterfaceClient_SetPropertiesUpdatedCallback(interfaceHandle, SettingsInterface_ProcessPropertyUpdate)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SETTINGS_INTERFACE: DigitalTwin_InterfaceClient_SetPropertiesUpdatedCallback failed. error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        SettingsInterface_Close(interfaceHandle);
        interfaceHandle = NULL;
    }

    else
    {
        LogInfo("SETTINGS_INTERFACE: Created DIGITALTWIN_INTERFACE_CLIENT_HANDLE successfully for interfaceId=<%s>, interfaceInstanceName=<%s>, handle=<%p>", SettingsInterfaceId, SettingsInterfaceInstanceName, interfaceHandle);
        appState.interfaceClientHandle = interfaceHandle;
    }

    return interfaceHandle;
}

void SettingsInterface_Close(DIGITALTWIN_INTERFACE_CLIENT_HANDLE digitalTwinInterfaceClientHandle)
{
    // On shutdown, in general the first call made should be to DigitalTwin_InterfaceClient_Destroy.
    // This will block if there are any active callbacks in this interface, and then
    // mark the underlying handle such that no future callbacks shall come to it.
    DigitalTwin_InterfaceClient_Destroy(digitalTwinInterfaceClientHandle);

    // After DigitalTwin_InterfaceClient_Destroy returns, it is safe to assume
    // no more callbacks shall arrive for this interface and it is OK to free
    // resources callbacks otherwise may have needed.

}
